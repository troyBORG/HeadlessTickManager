Comparison of Tick Rate Adjustment Models: User-Scaled vs. Join-Only Spike
Current Tick Rate Adjustment Logic (User-Scaled Model)

Overview: The HeadlessTickManager’s current model dynamically raises or lowers the server’s tick rate based on ongoing world activity (number of users and active worlds) and recent join bursts. In essence, the tick rate is calculated as:

```
tickRate = MinTickRate 
         + (WeightedUsers × AddedTicksPerUser) 
         + ((ActiveWorlds − 1) × AddedTicksPerWorld) 
         + JoinBonus

```
.

User Presence Scaling: Every non-host user contributes a fraction of extra ticks. By default, each additional user adds ~0.65 ticks (after weighting). This is applied per world with diminishing returns – users beyond a soft cap count less, and the busiest worlds are weighted more heavily. For example, one world with 20 users raises the tick rate to around 50 Hz, and a very large world (80 users) reaches ~80 Hz. Multiple active worlds further increase the rate (each extra active world adds ~1.8 ticks). In a heavy scenario (e.g. 4 worlds with ~50 users each), the tick rate hits the configured maximum (default 90 Hz). This ensures higher tick rates when many users or worlds are active, aiming to keep simulation and networking smooth under load.

Join Burst Handling: On top of the user-based rate, the model adds a temporary Join Bonus during spikes of user joins. It tracks recent join events in a short rolling window (default 25 seconds) and computes a “joins per minute” rate. For each join-per-minute, an extra tick boost (default 2.5 ticks per JPM) is added, capped at a safety maximum (default +12 ticks). In effect, a rapid burst of joins causes a short tick rate spike (e.g. a surge of new users can momentarily add up to 12 ticks to the rate). This helps absorb the extra load of login/spawn events and keep existing players’ experience smooth during the burst. The bonus decays as the join events age out of the window, and the tick rate then falls back toward the level dictated by active users/worlds. An exponential moving average (EMA) smoothing is applied to gradually adjust toward the target tick rate and avoid sudden jumps. Hysteresis and cooldown rules prevent oscillations from tiny changes or large rapid swings.

Summary: In the current model, more concurrent users and worlds = higher sustained tick rate, plus short-lived tick boosts for join spikes. The server ramps up when busy and returns to a 30 Hz floor when idle. This model prioritizes responsiveness under load, at the cost of increased CPU usage proportional to activity.

Alternate Strategy: Low Baseline with Join-Only Spikes

Overview: The alternative approach proposes maintaining a low baseline tick rate (e.g. the minimum 30 Hz) regardless of user count, and only spiking the tick rate in response to user join bursts. Once the burst passes, the tick rate would rapidly decay back to the idle baseline. In other words, the tick rate is decoupled from the steady-state number of users, and is instead only elevated transiently to handle incoming join load (to mitigate login hiccups).

Baseline Idle Rate: In this model, the server would remain at or near the minimum tick rate during normal operation, even if many users are present in multiple worlds. The tick rate no longer scales up with each additional user or world. For example, whether 5 users or 50 users are in a world, the tick might stay at 30 Hz (unless a recent join surge occurred). This is essentially achieved by removing the AddedTicksPerUser and AddedTicksPerWorld contributions from the formula (setting them to 0 so that tickRate ≈ MinTickRate + JoinBonus). Active worlds would no longer boost the tick rate on their own.

Join Burst Spikes: When a wave of players joins in a short time, the system would temporarily raise the tick rate to absorb the load. This could mean a quick jump from 30 Hz up to some higher value (potentially the max tick or a proportional bump) for the duration of the join burst. The same join-rate calculation (joins per minute within a time window) can be used to determine the spike magnitude. Once the join window passes (e.g. after ~25 seconds) and no further new joins are occurring, the tick rate would decay quickly back to the baseline. To achieve a rapid decay, the model could use a high reactivity (e.g. a higher EMA alpha for faster downward adjustment) or even an immediate drop once the burst is over. Essentially, the server only “revs up” around the moments of user entry, then returns to an idle pace.

Summary: In a join-only spike model, the tick rate stays low during steady-state usage (minimizing CPU usage) and only spikes temporarily for influxes of players, instead of scaling with total user count. This approach prioritizes conserving resources during normal operation while still addressing the specific stress of join events.

Pros and Cons Comparison
Server Performance and CPU Usage

Current User-Scaled Model: This approach dynamically allocates more CPU resources as usage grows, which helps maintain performance in busy scenarios. When many users or worlds are active, the higher tick rate means the server is doing more work per second (processing updates more frequently). This improves throughput and reduces per-frame load (preventing any single tick from getting overloaded) but at the cost of higher overall CPU utilization. The server is effectively working harder (and using more CPU time) in proportion to the active load. The benefit is that performance scales with demand – heavy usage is less likely to overwhelm the server because the tick rate increases to process events in smaller time slices. However, the downside is inefficient CPU usage during high-user periods if those extra cycles aren’t always needed. For instance, a world with 50 idle users would still run at an elevated tick rate, consuming considerably more CPU despite the users being inactive. In summary, this model can handle peak loads smoothly but runs the server “hotter” (more CPU, higher power draw) as user count rises.

Alternate Join-Only Spike Model: This strategy is very conservative in CPU usage during steady operation. By fixing the tick rate low (e.g. 30 Hz) for all normal activity, the server’s CPU load remains minimal regardless of how many users are connected. This is efficient – it avoids the continuous high CPU cost of a maxed-out tick rate when lots of users are present. In terms of general server performance, this could mean lower baseline temperatures and resource usage, leaving more headroom for other processes. The targeted spike during join bursts does momentarily increase CPU usage, but only for short intervals; it’s a short, intentional burst of load to handle a known expensive event (user logins). The trade-off is that under sustained heavy usage (many users interacting, multiple busy worlds), this model does not proactively allocate extra CPU. The server might remain at 30 Hz even while handling a large number of active users, which could risk slower processing of each tick if the workload per tick is very high. In extreme cases, if the fixed low tick can’t keep up with processing demands, the server could experience lag or longer frame times. Overall, the join-spike model saves CPU in the average case, but might under-utilize CPU and degrade performance during prolonged heavy activity since it doesn’t scale up to spread the work over more ticks.

Responsiveness and User Experience

Current User-Scaled Model: The primary advantage of this approach is maximized responsiveness for players during high activity. A higher tick rate means more frequent updates – physics, scripts, and network sync all run more times per second – which tends to make interactions smoother and latency lower for users. For example, with dozens of users in a session, the system may raise tick rate into the 60–90 Hz range, aligning with typical VR framerates and ensuring that avatars, objects, and interactions update fluidly. This leads to a better user experience in busy worlds: less input lag, more real-time feel, and reduced chance of missed frames or stutters. The join-burst handling further protects user experience by temporarily boosting tick during mass joins, so existing users don’t see hiccups when many new players spawn in. The downside is that running at high tick continuously could be overkill for user experience if the activity level doesn’t truly demand it – it’s essentially always optimizing for the worst case. There’s also a minor risk that pushing the server to a high tick under extreme load could backfire if the hardware can’t sustain it, potentially causing its own performance issues (the mod does cap and smooth changes to mitigate this). But in general, this model favors consistent smoothness and low latency for players at the expense of using more resources.

Alternate Join-Only Spike Model: This approach would yield a mixed user experience depending on the situation. During normal operation (no recent joins), the server runs at the low baseline tick. This could mean that even with many users in the world, updates are only happening at ~30 Hz. For users, that might translate to increased latency in interactions, less frequent physics updates, and a generally less responsive feel. In a VR/social context, a 30 Hz server tick could be noticeably laggy compared to 60 or 90 Hz – fast-moving objects or user motions might update in a choppier fashion. Thus, with large numbers of active users, their experience may degrade in terms of real-time responsiveness (e.g. more delay in seeing others’ actions). On the other hand, the model’s strength is that during the critical moment of joining, it boosts the tick rate to avoid stutters. So new players logging in experience a smooth entry (and do not cause lag for others), and then once things settle, the server conserves resources. If the worlds are relatively passive or users mostly idle after joining, they might not notice the low tick rate. But if they are interacting heavily, the low continuous tick could hamper the experience. In summary, the join-spike model prioritizes smoothness only around join events, and sacrifices some real-time fidelity during ongoing activity. This could be acceptable in use cases where peak interactivity isn’t needed, but it risks lower responsiveness for users in busy worlds compared to the current scaling approach.

Implementation Considerations for a Join-Only Spike Model

To implement the alternate join-spike strategy, several changes and tuning adjustments are needed:

Decouple Tick Rate from User Count: The core change is to remove the direct scaling by user and world counts. In practice, this means disabling or zeroing out the AddedTicksPerUser and AddedTicksPerWorld contributions. For example, these coefficients (0.65 and 1.8 by default) could be set to 0 in the configuration, so that the formula effectively becomes tickRate = MinTickRate + JoinBonus only. This would require modifying the TickController calculation to ignore user-based terms. With this change, the tick rate will remain at MinTickRate (baseline) in the steady state, regardless of how many users/worlds are active.

Retain and Refine Join Burst Logic: The join tracking mechanism (using a queue of recent joins within a short window) can be kept largely as-is to trigger tick spikes. However, we may want to tune the join spike parameters since they become the sole driver of tick increases. The default settings allow up to +12 ticks for a heavy join rate – under a 30 Hz baseline, that would spike to ~42 Hz max during a burst. If the goal is to momentarily hit a much higher tick (to, say, max out at 90 Hz) during very large join events, we might raise the JoinRateTicksPerJpm or the JoinRateMaxBonusTicks limit. For instance, allowing the join bonus to add, say, up to +60 ticks (for a short time) could let the server hit full speed when dozens of users join at once. This must be balanced to avoid overshooting CPU capabilities. Fine-tuning the JoinWindowSeconds is also important – a shorter window (e.g. 15–20s) would make the spike more immediate and short-lived, whereas a longer window would prolong the elevated tick after a burst.

Faster Decay to Baseline: In the current model, an exponential smoothing (EMA) is used to slowly ease the tick rate up or down. For a join-only spike approach, we likely want the tick to drop back quickly after the burst. There are a few implementation options:

Increase the EMA’s responsiveness (EmaAlpha). The default alpha is 0.25 (25% new value, 75% inertia); raising this (toward 0.5 or higher) would make the tick rate track the target more closely, shortening the tail of the spike. Essentially, the tick would fall back to 30 Hz more rapidly once the join bonus goes away.

Use the existing InstantIdleDrop concept (or a variant) to snap the tick down when appropriate. Currently, InstantIdleDrop=true immediately drops to min tick when no active worlds remain. In a join-only model, we could extend a similar idea: as soon as the join rate falls to zero (no recent joins), and perhaps if no other load is detected, instantly return to the baseline tick. This might require new logic since in the alternate model there will typically still be active worlds (just with no join bonus). One could implement a check like “if target tick = MinTickRate (no join bonus) for a few seconds, then force an immediate snap-down instead of gliding.”

Ensure the hysteresis and cooldown settings are adjusted appropriately. We’d allow the tick to drop without a long enforced delay. The current hysteresis (ignore changes <2 ticks) and min change interval (4s) are relatively small, so they likely can remain as is. But the “big jump” cooldown might need reconsideration: in a join spike scenario, a large upward jump followed by a large downward jump happens by design. We may want to disable or shorten the cooldown (BigJumpThreshold/CooldownSeconds) so that the tick can rise and fall swiftly around join events without being stuck high or low for extra time.

Testing and Edge Cases: Switching to a join-only model is a significant behavior change, so careful testing is needed. One should monitor how the server performs with many users when tick remains low – e.g., check for any lag or timing issues. It’s possible some internal systems assume higher tick at scale; these would need evaluation. Additionally, with tick largely static, the join detection becomes critical – ensure that every user join triggers the spike promptly. This may involve hooking into the user join event as is done (the mod already enqueues joins on OnUserJoin calls) and verifying no joins are missed. Also, consider scenarios like continuous trickle of joins: the system should handle back-to-back small bursts (e.g. if users keep joining one after another, the tick might need to stay elevated a bit longer). Parameter tuning (window and decay) will be key to avoid either cutting off the spike too soon or keeping it up too long.

Configuration Flexibility: Implementing this could be done by adding a mode toggle in the config (e.g. a boolean for “JoinOnlyMode”). When enabled, the mod would internally ignore user counts and only use join-based scaling. This would make it easy to switch between the original behavior and the new strategy. Alternately, documenting that setting AddedTicksPerUser and AddedTicksPerWorld to 0 achieves the effect could suffice for advanced users. For maintainability, clearly separating the two models’ code paths would help (to avoid complicating the current calculations with too many conditionals). Essentially, much of the existing code can be reused, but with the user/world contributions nullified and possibly a special-case to drop tick when join activity subsides.

In conclusion, moving to a join-only spike model is achievable by simplifying the tick formula to exclude user scaling and tweaking the timing/smoothing parameters. The benefits and drawbacks should be carefully weighed: it saves resources and handles login bursts well, but it requires confidence that a low steady tick won’t harm the experience for large active sessions. The implementation would involve configuration changes and some adjusted logic as described, with thorough testing to ensure the server remains stable and user experience stays acceptable under the new model.